/*
 * Parser for the mOZ language. Claudio Antares Mezzina
 * Contributors:
 *      Davide Riccardo Caliendo - grammar/parsing for expressions and operator precedence
 */
options
{
    JDK_VERSION = "1.6";
    static = true;

    FORCE_LA_CHECK= true;
    LOOKAHEAD=1;
} 

//t.beginColumn and t.beginLine for error outputting 
PARSER_BEGIN(mozParser) 
package parser;

import java.io.*;
import language.statement.*;
import language.value.*;
import language.value.expression.*;
import java.util.*;
import language.util.Tuple;

import parser.ParseException;

public class mozParser 
{
    static mozParser parser = null;

    public static IStatement parse(InputStream pgm) throws ParseException {
        IStatement program = null;
        // create a parser (this object)
        parser = new mozParser(pgm);
        System.out.println("started parsing ....");
        try {
            program = mozParser.parse();
        } catch(ParseException pe) {
            System.out.println("Error in parsing program: " + pe.getMessage());
            System.exit(-1); 
        }
        return program;
    }
}

PARSER_END(mozParser)

SKIP :
{
    " "
    | "\r"
    | "\t"
    | "\n"
    | < "//" (~["\n" ])* >	//there was a trailing \n before
}	

SKIP :
{
    < "/*" > : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    < "*/" > : DEFAULT
    | < ~[] >
}

//language keywords
TOKEN:
{
    < LET : "let">
    | < EQ : "=">
    | < SK: "skip">
    | < SC : ";" >
    | < COMMA : "," >
    | < IF : "if" >
    | < THEN : "then" >
    | < ELSE : "else" > 
    | < SEND : "send" >
    | < REC : "receive" >
    | < IN : "in" > 
    | < END : "end" >
    | < TRUE : "true" >
    | < FALSE : "false" >
    | < THR	: "thread" >
    | < PROC : "proc" > 
    | < CL  : "{" >
    | < CR : "}" >
    | < PL: "(">
    | < PR: ")">
    | < PORT : "port">
    | < ISEQ : "==" >
    | < ISNEQ : "\\=" >
    | < GT : ">" >
    | < LT : "<" >
    | < LE : "<=" >
    | < GE : ">=" >
    | < MUL : "*" >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < DIV : "/" >
    | < MOD : "%" >
    | < AND : "&&" >
    | < OR : "||" >
    | < BITAND : "&" >
    | < BITOR : "|" >
    | < NOT : "~" >
    | < BR : "<br>">
    | < ASS : "assert" >
}
//identifiers
TOKEN :
{
    <ID:["a"-"z","A"-"Z"](["a"-"z","_","0"-"9","A"-"Z"])*>
}
TOKEN :
{
    < INUMBER : ["1"-"9"](["0"-"9"])*>
    // separate rule to simplify the regex
    | < IZERO  : "0" >
    | < FNUMBER: (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]>
    | <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
    |<STRING :
        "\""
        (
              ~["\"", "\\"]
            | "\\" ["r", "n", "\"", "\\"]
            | "\"" "\""
        )*
        "\""
      >
}

/* STATEMENTS */

IStatement parse():
{
    IStatement pgm = null; 
}
{
    pgm = stm_list() < EOF>
    {
        return pgm;
    }
}

//sequential composition of statements
IStatement stm_list():
{
    IStatement sx = null;
    IStatement dx = null;
}
{
    sx = stm() (< SC> dx = stm(){
        sx = new Sequence(sx, dx);
    })*
    {
        return sx;
    }
} 


IStatement stm():
{	
    Token t=null;
    Token boolOp=null;
    IValue val;
    Expression boolexp;
    IStatement sx = null;
    IStatement dx = null;	
    ArrayList< String> args;
}
{
    //skip 	
    < SK >
    {
        return new Skip();
    }
    | 
    <BR>
    {
        return new BreakStatemet(); 
    }
    |
    // assert
    < ASS > boolexp=expression()
    {
        return new Assert(boolexp);
    }
    |
    //should put a trailing end ...
    < IF>  boolexp=expression() < THEN> sx = stm_list() < ELSE> dx = stm_list() < END>
    {
        return new Conditional(boolexp, sx, dx);
    }
    |
    < LET> t =< ID> < EQ> (val = receive() | val = procedure() | val = portcreation() | val = expression()) <IN > sx = stm_list() < END>
    {
        return new Assignment(t.toString(), val, sx);
    }
    |	
    //thread creation 
    sx = spawn()
    {
        return sx;
    }
    //procedure invocation
    | 	
    // send or procedure invocation
    < CL>(
          sx = send()
          | 		 	
          args = var_list()
          {
              //the first element of the list is the invoked procedure
              if(args.size() >0)
              {
                  String proc_name = args.remove(0);
                  sx = new Invoke(proc_name, args);
               }
          }
         )
    < CR>
    {
        return sx;
    }

}

//creation new thread
IStatement spawn():
{
    IStatement body;
}
{
    < THR> body = stm_list() < END>
    {
        return new ThreadStm(body);
    }
}

IStatement send():
{ 
    Token chan,value;
}
{
    < SEND> chan = < ID> value= < ID>
    {
        return new Send(chan.toString(), value.toString());
    }
}

/* VALUES */ 
Receive receive():
{
    Token id;
}
{
    < CL> <REC > id =< ID>< CR >
    {
        return new Receive(id.toString());
    } 
}

Procedure procedure():
{
    ArrayList< String> var= null;
    IStatement stmlist = null;
    Token id;
}
{
    < PROC> var = proc_var() stmlist = stm_list() < END > 
    {
        return new Procedure(var, stmlist);
    }
}

ArrayList< String> proc_var():
{
    ArrayList< String> ret;
}

{
    < CL> ret = var_list()< CR>
    {
        return ret;
    }   
}

PortCreation portcreation():
{
}
{
    < PORT>
    {
        return new PortCreation();
    }
}


/* EXPRESSIONS */

BoolConst bool():
{
    Token t;
}
{
    (t = < TRUE> | t = < FALSE>)
    {
        return new BoolConst(t.toString());
    } 
}

IntConst inumber():
{
    Token t;
}
{
    t=< INUMBER>
    {
        return new IntConst(t.toString());
    }
    |
    t=< IZERO>
    {
        return new IntConst(t.toString());
    }
}

FloatConst fnumber():
{
    Token t;
}
{
    t=< FNUMBER>
    {
        return new FloatConst(t.toString());
    }
}

StringConst string():
{
    Token t;
    String s;
}
{
    t = < STRING>
    {
        // we must drop the first and last char of the token, they are quotes
        s = t.toString();
        s = s.substring(1, s.length() - 1);
        return new StringConst(s);
    }
}

SimpleId var():
{
    Token t;
}
{
    t = < ID>
    {
        return new SimpleId(t.toString());
    }
}

/* operators have this precedence relation,
 * from the strongest:
 * ( )
 * * , / , %
 * + , -
 * & , |  (bitwise operators) 
 * > , < , <= , >=, == , \=
 * ! 
 * &&
 * ||
 */
Expression expression():
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
}
{
    e = and_test() (t = < OR> f = and_test() 
                    {
                        opname = t.toString();
                        if (opname.equals("||"))
                            e = new BinaryOp(e, f, BinaryOpType.OR, opname);
                    })*
    {
        return e;
    }
}


Expression and_test():
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
}
{
    e = not_test() (t = < AND>  f = not_test()
            {
                opname = t.toString();
                if (opname.equals("&&"))
                    e = new BinaryOp(e, f, BinaryOpType.AND, opname);
            })*
    {
        return e;
    }
}

Expression not_test():
{
    Expression e = null;
    Token t = null;
    String opname;
}
{
    ((t = < NOT>  e = not_test() ) | e = compare())
    {
        
        if (t == null)
            return e;
        
        opname = t.toString();
        return new UnaryOp(e, UnaryOpType.INV, opname);       
    }
}

Expression compare(): 
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
}
{
    e = bit_expr() ((t = < ISEQ> | t = < ISNEQ> | t = < GT> | t = < GE> | t = < LT> | t = < LE>) f = bit_expr()
            {
                opname = t.toString();
                if (opname.equals("=="))
                    e = new BinaryOp(e, f, BinaryOpType.EQ, opname);
                if (opname.equals("\\="))
                    e = new BinaryOp(e, f, BinaryOpType.NEQ, opname);
                if (opname.equals(">"))
                    e = new BinaryOp(e, f, BinaryOpType.GT, opname);
                if (opname.equals(">="))
                    e = new BinaryOp(e, f, BinaryOpType.GTE, opname);
                if (opname.equals("<"))
                    e = new BinaryOp(e, f, BinaryOpType.LT, opname);
                if (opname.equals("<="))
                    e = new BinaryOp(e, f, BinaryOpType.LTE, opname);
            })*
    {
        
        return e;
    }
}

Expression bit_expr():
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
}
{
    e = arith_expr() ((t = < BITAND> | t = < BITOR>) f = arith_expr()
            {
                opname = t.toString();
                if (opname.equals("&"))
                    e = new BinaryOp(e, f, BinaryOpType.AND, opname);
                if (opname.equals("|"))
                    e = new BinaryOp(e, f, BinaryOpType.OR, opname);
            })*
    {
        return e;
    }
}

Expression arith_expr():
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
    ArrayList< Expression> expr_list = new ArrayList< Expression>();
    Iterator < Tuple<Token, Expression>> eit;
    Tuple < Token, Expression> ts;
}
{
    e = term() ((t = < PLUS> | t = < MINUS>) f = term()
            { 
                opname = t.toString();
                if (opname.equals("+")){
                    e = new BinaryOp(e, f, BinaryOpType.ADD, opname);
                }
                if (opname.equals("-")){
                    e = new BinaryOp(e, f, BinaryOpType.SUB, opname);
                }
            })*
    {
        return e;
    }
}

Expression term():
{
    Expression e = null, f = null;
    Token t = null;
    String opname;
}
{   
   e = factor() ((t = < MUL> | t = < DIV> | t = < MOD> ) f = factor()
           {
               opname = t.toString();
               if (opname.equals("%"))
                   e = new BinaryOp(e, f, BinaryOpType.MOD, opname);
               if (opname.equals("*"))
                   e =  new BinaryOp(e, f, BinaryOpType.MUL, opname);
               if (opname.equals("/")) {
                   e = new BinaryOp(e, f, BinaryOpType.DIV, opname);
               }
           })*
   {
       return e;
   }
}

Expression factor():
{
   Expression e;
   Token t = null;
}
{
    < PL> e = expression() < PR>
    {
        return new GroupedExpression(e);
    }
    |
    (e = inumber() | e = fnumber() | e = string() | e = bool() | e = var())
    {
        return e;
    }
    |
    (t = < MINUS> e =  factor() |t = < PLUS> e =  factor())
    {
        if (t.toString().equals("+"))
            return new UnaryOp(e, UnaryOpType.POS, t.toString());
        else
            return new UnaryOp(e, UnaryOpType.NEG, t.toString());       
    }
}

/* VARIOUS */
ArrayList< String> var_list():
{
    Token id;
    ArrayList< String> ret = new ArrayList< String>();
}
{
    (id = < ID>
     {
        ret.add(id.toString());
     }

    )*
    {
        return ret;
    }
}